#include <iostream>
#include <string>
#include <list>
#include <climits>
#include <stdlib.h>
#include <locale.h>
#include <stdio.h>
#include <queue>// É uma biblioteca alternativa ao list, com ele não é necesário escrever as funções básicas como "pop_front","push_back"
#include <cmath>
using namespace std;

// Definição da estrutura para representar uma aresta
struct no {
    int vertice; // vértice adjacente
    int peso;    // peso da aresta
};

struct Cidades {
    int codigo;
    string nome;
    char temCentroPokemon;
};

// Estrutura para representar um Pokemon
struct Pokemon {
    string nome;
    string tipo;
    int numero;
    int posx;
    int posy;
};

struct Pokedex {
    int posx,posy;
};

// Função para criar uma aresta entre os vértices u e v com peso p
void cria_aresta(list<no> adj[], int u, int v, int p, int orientado) {
    no x;
    x.vertice = v;
    x.peso = p;
    adj[u].push_back(x); // Adiciona a aresta na lista de adjacência do vértice u
    if (orientado == 0) {
        x.vertice = u;
        adj[v].push_back(x); // Adiciona a aresta na lista de adjacência do vértice v (se não for orientado)
    }
}
//Utilizei esse modelo pois ele é para grafos ponderados direcionados e não direcionados, achado para caminhos mais curtos
// Função para calcular o menor caminho utilizando o algoritmo de Dijkstra
void dijkstra(list<no> adj[], int nVertices, int codigo_atual, int codigo_final) {
    // Vetor para rastrear os vértices incluídos na MST
    bool intree[nVertices] = {false};
    // Vetor para armazenar as distâncias mínimas
    int distance[nVertices];
    // Vetor para armazenar os pais na MST
    int parent[nVertices];

    for (int i = 0; i < nVertices; i++) {
        distance[i] = INT_MAX;
        parent[i] = -1;
    }

    distance[codigo_atual] = 0; // Define a distância do vértice inicial como 0
    int v = codigo_atual;        // Inicia do vértice de início

    // Algoritmo de Dijkstra
    while (!intree[v]) {
        intree[v] = true; // Marca o vértice como incluído na MST

        // Itera sobre todas as arestas adjacentes ao vértice atual
        for (auto it = adj[v].begin(); it != adj[v].end(); ++it) {
            int dest = it->vertice;
            int weight = it->peso;

            // Se o vértice não estiver na MST e a distância mínima até ele for atualizável
            if (!intree[dest] && distance[dest] > distance[v] + weight) {
                distance[dest] = distance[v] + weight; // Atualiza a distância mínima
                parent[dest] = v; // Atualiza o pai
            }
        }

        // Encontra o vértice mais próximo que não está na MST
        v = 0;
        int dist = INT_MAX;
        for (int u = 0; u < nVertices; ++u) {
            if (!intree[u] && dist > distance[u]) {
                dist = distance[u];
                v = u;
            }
        }
    }

    // Constrói o vetor caminho
    int caminho[nVertices];
    int index = 0;
    int at = codigo_final;
    while (at != -1) {
        caminho[index++] = at;
        at = parent[at];
    }

    // Imprime o menor caminho
    cout << "Menor caminho: ";
    for (int i = index - 1; i >= 0; --i) {
        cout << caminho[i];
        if (i > 0)
            cout << " ";
    }
    cout << endl;

    // Calcula o custo do caminho
    int custoCaminho = 0;
    for (int i = index - 1; i > 0; --i) {
        int u = caminho[i];
        int v = caminho[i - 1];
        for (auto it = adj[u].begin(); it != adj[u].end(); ++it) {
            if (it->vertice == v) {
                custoCaminho += it->peso;
                break;
            }
        }
    }
    cout << "Custo: " << custoCaminho << endl;
}

// Estrutura para o nó de uma Árvore binária
struct Arvore {
    Pokemon pokemon;
    Arvore* esquerda;
    Arvore* direita;
};

typedef Arvore* arvoreptr;

// Função para inserir um Pokemon na árvore binária mantendo a ordem alfabética pelo nome
void inserirPorNome(arvoreptr &raiz, Pokemon pokemon) {
    if (raiz == NULL){
        raiz = new Arvore;
        raiz->pokemon = pokemon;
        raiz->esquerda = NULL;
        raiz->direita = NULL;
    }
    else if(pokemon.nome < raiz->pokemon.nome)
        inserirPorNome(raiz->esquerda,pokemon);
    else
        inserirPorNome(raiz->direita,pokemon);
}

void inserirPorTipo(arvoreptr &raiz, Pokemon pokemon) {
    if (raiz == NULL){
        raiz = new Arvore;
        raiz->pokemon = pokemon;
        raiz->esquerda = NULL;
        raiz->direita = NULL;
    }
    else if(pokemon.tipo < raiz->pokemon.tipo)
        inserirPorTipo(raiz->esquerda,pokemon);
    else
        inserirPorTipo(raiz->direita,pokemon);
}

arvoreptr buscarPokemon(arvoreptr raiz, string nome){
    if(raiz == NULL)
        return NULL;
    else if(nome == raiz->pokemon.nome)
        return raiz;
    else if(nome < raiz->pokemon.nome)
        return buscarPokemon(raiz->esquerda,nome);
    else
        return buscarPokemon(raiz->direita,nome);
}

void inOrder(arvoreptr raiz){
    if(raiz != NULL){
        inOrder(raiz->esquerda);
        cout << "Nome do Pokemon: " << raiz->pokemon.nome<<endl;
        cout << "Tipo do Pokemon: " << raiz->pokemon.tipo<<endl;
        cout << "Código do Pokemon na Pokedex: " << raiz->pokemon.numero<<endl;
        cout << "Coordenadas do Pokemon: x= " << raiz->pokemon.posx <<" y= "<<raiz->pokemon.posy<<endl;
        cout << endl;
        inOrder(raiz->direita);
    }
}

void destruirArvore(arvoreptr &raiz){
    if(raiz != NULL){
        destruirArvore(raiz->esquerda);
        destruirArvore(raiz->direita);
        delete raiz;
    }
    raiz = NULL;
}

void emNivel(arvoreptr raiz, Pokedex pokedex){
    float dist,difPosX,difPosY;
    int numPokemons = 0;
    if(raiz != NULL){
        queue<arvoreptr> fila;
        fila.push(raiz);
        while(!fila.empty()){
            arvoreptr atual = fila.front();
            fila.pop();
            difPosX = pow((pokedex.posx - atual->pokemon.posx),2);
            difPosY = pow((pokedex.posy - atual->pokemon.posy),2);
            dist = sqrt(difPosX+difPosY);
            if(dist<=100)
                numPokemons++;
            if(atual->esquerda!=NULL)
                fila.push(atual->esquerda);
            if(atual->direita!=NULL)
                fila.push(atual->direita);
        }
    }
    cout << "Existem " << numPokemons << " pokémons em um raio de 100 metros da Pokedex"<<endl;
}

void contarPorTipo(arvoreptr raiz, int &cont, string tipo) {
    if (raiz == NULL) {
        return;
    }
    // Conta o Pokémon atual
    if(raiz->pokemon.tipo == tipo)
    cont++;
    // Chama a função para os filhos esquerdo e direito
    contarPorTipo(raiz->esquerda, cont,tipo);
    contarPorTipo(raiz->direita, cont, tipo);
}

int main() {
    setlocale(LC_ALL, "portuguese");
    // Variáveis
    int contador_cidades = 0;
    int orientado = 1;
    int codigo_atual;
    int codigo_final;
    int u; // Vértice de origem
    int v; // Vértice de destino
    int p; // Peso
    int i = 0; // Inicializa a variável i
    arvoreptr arvorePorNome = NULL;
    arvoreptr arvorePorTipo = NULL;
    arvoreptr resultado;
    Pokemon pkm;
    string nomePokemon;
    Pokedex Pokedex;
    Cidades city[10000];
    list<no> adj[10000];

    // Loop principal do programa
    while (true) {
        system("cls");
        cout << "Bem-vindo a sua Pokedex" << endl;
        cout << "Escolha uma das funcoes disponiveis" << endl;
        cout << "1 - Cadastrar uma cidade" << endl;
        cout << "2 - Mostrar o Centro Pokemon mais próximo" << endl;
        cout << "3 - Cadastrar um Pokemon" << endl;
        cout << "4 - Listar os Pokemons por ordem alfabética dos nomes" << endl;
        cout << "5 - Buscar Pokémon pelo Nome" << endl;
        cout << "6 - Listar os Pokemons por ordem alfabética dos tipos" << endl;
        cout << "7 - Contar Pokemons cadastrados por tipo" << endl;
        cout << "8 - Mostrar Pokemons no alcance da Pokedex" << endl;
        cout << "0 - Desligar Pokedex" << endl;
        cout << "Opcao: ";

        int opcao;
        cin >> opcao;

        // Switch para escolher a opção do menu
        switch (opcao) {
        
        case 0:
            system("cls");
            destruirArvore(arvorePorNome);
            destruirArvore(arvorePorTipo);
            exit(0); // Sai do programa
        
        case 1: // Cadastro de Cidade
            do {
                i++;
                cout << "Digite o código da cidade: ";
                cin >> city[i].codigo;
                cout << "Digite o nome da cidade: ";
                cin.ignore();
                getline(cin, city[i].nome);
                cout << "A cidade tem Centro Pokemon: S/N: ";
                cin >> city[i].temCentroPokemon;

                contador_cidades++;

                cout << "Deseja continuar cadastrando cidades? (0 - Sim / 1 - Não): ";
                cin >> opcao;
            } while (opcao != 1);
            break;

        case 2:
            system("cls");
            cout << "Código da cidade atual: ";
            cin >> codigo_atual;

            cout << "Esses são os códigos das cidades que possuem Centro de Pokemon: ";
            for (int j = 1; j <= contador_cidades; j++) // Início do loop a partir de 1
            {
                if (city[j].temCentroPokemon == 'S') // Ajuste no índice para city
                {
                    cout << city[j].codigo << " ";
                }
            }
            cout << endl;

            cout << "Código de destino (Cidade que possui Centro de Pokemon): ";
            cin >> codigo_final;

            cout << "Insira as arestas do grafo (origem destino peso), digite -1 -1 -1 para terminar:" << endl;
            while (true) {
                cin >> u >> v >> p;
                if (u == -1 && v == -1 && p == -1) {
                    break;
                }

                cria_aresta(adj, u, v, p, orientado); // Cria a aresta entre os vértices u e v com peso p
            }

            dijkstra(adj, contador_cidades, codigo_atual, codigo_final);
            break;

        case 3: // Cadastro de Pokemon
            system("cls");
            cout << "Digite o nome do Pokemon: ";
            cin >> pkm.nome;
            cout << "Digite o tipo do Pokemon: ";
            cin >> pkm.tipo;
            cout << "Digite o numero do Pokemon: ";
            cin >> pkm.numero;
            cout << "Digite a coordenada x do Pokemon: ";
            cin >> pkm.posx;
            cout << "Digite a coordenada y do Pokemon: ";
            cin >> pkm.posy;
            inserirPorNome(arvorePorNome,pkm);
            inserirPorTipo(arvorePorTipo,pkm);
            break;
        
        case 4:
            system("cls");
            inOrder(arvorePorNome);
            break;
        
        case 5:
            system("cls");
            cout << "Digite o nome do Pokemon que deseja buscar: ";
            cin >> nomePokemon;
            resultado = buscarPokemon(arvorePorNome,nomePokemon);
            if(resultado == NULL)
                cout << "Pokémon não encontrado!"<<endl;
            else
                cout << "Pokémon encontrado!"<<endl;
            break;
        
        case 6:
            system("cls");
            inOrder(arvorePorTipo);
            break;
            
        case 7: // Contagem de Pokemons por tipo
            {
                int cont = 0;
                string tipo;
                cout<<"Tipo desejado: ";
                cin >> tipo;
                
                contarPorTipo(arvorePorTipo, cont, tipo);
                 
                cout<<"Existem "<<cont << " desse tipo." <<endl;
                break;
            }
        
        case 8:
            cout << "Entre com a posição x da Pokedex: ";
            cin >> Pokedex.posx;
            cout << "Entre com a posição y da Pokedex: ";
            cin >> Pokedex.posy;
            emNivel(arvorePorNome,Pokedex);
            break;
        }
        
        // Verifica se o usuário deseja voltar ao menu principal
        cout << "Deseja voltar ao menu principal? (S/N)" << endl;
        char menu;
        cin >> menu;
        if (toupper(menu) == 'N') // Converte a entrada para maiúsculas e verifica se é 'N'
        {
            destruirArvore(arvorePorNome);
            destruirArvore(arvorePorTipo);
            exit(0); // Sai do programa
        }
    }
    return 0;
}


/*
Caso de teste do djkistra
Cadastrar 5 cidades (Código - Nome - Possui Centro)
0 A S
1 B S
2 C S
3 D N
4 E N

Cidade atual: 0
Cidade Final: 2 

Origem, Destino, Peso 
0 1 10 
0 4 5 
1 2 1 
1 4 2 
2 3 4 
3 0 7 
3 2 6 
4 1 3 
4 2 9 
4 3 2 
-1 -1 -1 



Contar Pokemons cadastrados por tipo 
Pokedex: 
x= 25 
y = 25

Pkm1 
x = 125 
y = 250

dBA = 246
